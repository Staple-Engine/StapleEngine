// Generated by Sichem at 2/16/2021 5:32:50 PM

using System.Runtime.InteropServices;

namespace StbImageResizeSharp
{
	unsafe partial class StbImageResize
	{
		public const int STBIR_EDGE_CLAMP = 1;
		public const int STBIR_EDGE_REFLECT = 2;
		public const int STBIR_EDGE_WRAP = 3;
		public const int STBIR_EDGE_ZERO = 4;
		public const int STBIR_FILTER_DEFAULT = 0;
		public const int STBIR_FILTER_BOX = 1;
		public const int STBIR_FILTER_TRIANGLE = 2;
		public const int STBIR_FILTER_CUBICBSPLINE = 3;
		public const int STBIR_FILTER_CATMULLROM = 4;
		public const int STBIR_FILTER_MITCHELL = 5;
		public const int STBIR_COLORSPACE_LINEAR = 0;
		public const int STBIR_COLORSPACE_SRGB = 1;
		public const int STBIR_MAX_COLORSPACES = 2;
		public const int STBIR_TYPE_UINT8 = 0;
		public const int STBIR_TYPE_UINT16 = 1;
		public const int STBIR_TYPE_UINT32 = 2;
		public const int STBIR_TYPE_FLOAT = 3;
		public const int STBIR_MAX_TYPES = 4;

		public enum stbir_colorspace
		{
			STBIR_COLORSPACE_LINEAR,
			STBIR_COLORSPACE_SRGB,
			STBIR_MAX_COLORSPACES
		}

		public enum stbir_datatype
		{
			STBIR_TYPE_UINT8,
			STBIR_TYPE_UINT16,
			STBIR_TYPE_UINT32,
			STBIR_TYPE_FLOAT,
			STBIR_MAX_TYPES
		}

		public enum stbir_edge
		{
			STBIR_EDGE_CLAMP = 1,
			STBIR_EDGE_REFLECT = 2,
			STBIR_EDGE_WRAP = 3,
			STBIR_EDGE_ZERO = 4
		}

		public enum stbir_filter
		{
			STBIR_FILTER_DEFAULT = 0,
			STBIR_FILTER_BOX = 1,
			STBIR_FILTER_TRIANGLE = 2,
			STBIR_FILTER_CUBICBSPLINE = 3,
			STBIR_FILTER_CATMULLROM = 4,
			STBIR_FILTER_MITCHELL = 5
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct stbir__contributors
		{
			public int n0;
			public int n1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct stbir__info
		{
			public void* input_data;
			public int input_w;
			public int input_h;
			public int input_stride_bytes;
			public void* output_data;
			public int output_w;
			public int output_h;
			public int output_stride_bytes;
			public float s0;
			public float t0;
			public float s1;
			public float t1;
			public float horizontal_shift;
			public float vertical_shift;
			public float horizontal_scale;
			public float vertical_scale;
			public int channels;
			public int alpha_channel;
			public uint flags;
			public int type;
			public int horizontal_filter;
			public int vertical_filter;
			public int edge_horizontal;
			public int edge_vertical;
			public int colorspace;
			public stbir__contributors* horizontal_contributors;
			public float* horizontal_coefficients;
			public stbir__contributors* vertical_contributors;
			public float* vertical_coefficients;
			public int decode_buffer_pixels;
			public float* decode_buffer;
			public float* horizontal_buffer;
			public int horizontal_coefficient_width;
			public int vertical_coefficient_width;
			public int horizontal_filter_pixel_width;
			public int vertical_filter_pixel_width;
			public int horizontal_filter_pixel_margin;
			public int vertical_filter_pixel_margin;
			public int horizontal_num_contributors;
			public int vertical_num_contributors;
			public int ring_buffer_length_bytes;
			public int ring_buffer_num_entries;
			public int ring_buffer_first_scanline;
			public int ring_buffer_last_scanline;
			public int ring_buffer_begin_index;
			public float* ring_buffer;
			public float* encode_buffer;
			public int horizontal_contributors_size;
			public int horizontal_coefficients_size;
			public int vertical_contributors_size;
			public int vertical_coefficients_size;
			public int decode_buffer_size;
			public int horizontal_buffer_size;
			public int ring_buffer_size;
			public int encode_buffer_size;
		}

		public static readonly byte[] stbir__type_size = { 1, 2, 4, 4 };
		public static readonly float stbir__max_uint8_as_float = 255.0f;
		public static readonly float stbir__max_uint16_as_float = 65535.0f;
		public static readonly double stbir__max_uint32_as_float = 4294967295.0;

		public static readonly float[] stbir__srgb_uchar_to_linear_float =
		{
			0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f, 0.002428f,
			0.002732f, 0.003035f, 0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f, 0.005182f, 0.005605f,
			0.006049f, 0.006512f, 0.006995f, 0.007499f, 0.008023f, 0.008568f, 0.009134f, 0.009721f, 0.010330f,
			0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f, 0.015209f, 0.015996f, 0.016807f,
			0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f, 0.025187f,
			0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f,
			0.036889f, 0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f,
			0.049707f, 0.051269f, 0.052861f, 0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f,
			0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f, 0.074214f, 0.076185f, 0.078187f, 0.080220f,
			0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f, 0.097587f, 0.099899f,
			0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f, 0.116971f, 0.119538f, 0.122139f,
			0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f, 0.141263f, 0.144128f, 0.147027f,
			0.149960f, 0.152926f, 0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f,
			0.177888f, 0.181164f, 0.184475f, 0.187821f, 0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f,
			0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f, 0.230740f, 0.234551f, 0.238398f,
			0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f, 0.274677f,
			0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f,
			0.318547f, 0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f,
			0.361307f, 0.366253f, 0.371238f, 0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f,
			0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f, 0.434154f, 0.439657f, 0.445201f, 0.450786f,
			0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f, 0.485150f, 0.491021f, 0.496933f, 0.502887f,
			0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f,
			0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f,
			0.623960f, 0.630757f, 0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f,
			0.686685f, 0.693872f, 0.701102f, 0.708376f, 0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f,
			0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f, 0.799103f, 0.806952f, 0.814847f,
			0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f, 0.887923f,
			0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f,
			0.973445f, 0.982251f, 0.991102f, 1.0f
		};

		public static readonly uint[] fp32_to_srgb8_tab4 =
		{
			0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d, 0x00a7001a,
			0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a, 0x010e0033, 0x01280033,
			0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033, 0x01dc0067, 0x020f0067, 0x02430067,
			0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067, 0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce,
			0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5, 0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112,
			0x09940106, 0x0a1700fc, 0x0a9500f2, 0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e,
			0x0fbc0150, 0x10630143, 0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0,
			0x182401af, 0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,
			0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300, 0x31d105b0,
			0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401, 0x44c20798, 0x488e071e,
			0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559, 0x5e0c0a23, 0x631c0980, 0x67db08f6,
			0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723
		};

		public static readonly stbir__filter_info[] stbir__filter_info_table =
		{
			new stbir__filter_info {kernel = null, support = stbir__support_zero},
			new stbir__filter_info {kernel = stbir__filter_trapezoid, support = stbir__support_trapezoid},
			new stbir__filter_info {kernel = stbir__filter_triangle, support = stbir__support_one},
			new stbir__filter_info {kernel = stbir__filter_cubic, support = stbir__support_two},
			new stbir__filter_info {kernel = stbir__filter_catmullrom, support = stbir__support_two},
			new stbir__filter_info {kernel = stbir__filter_mitchell, support = stbir__support_two}
		};

		public static int stbir__min(int a, int b)
		{
			return a < b ? a : b;
		}

		public static float stbir__saturate(float x)
		{
			if (x < 0)
				return 0;
			if (x > 1)
				return 1;
			return x;
		}

		public static float stbir__srgb_to_linear(float f)
		{
			if (f <= 0.04045f)
				return f / 12.92f;
			return (float)CRuntime.pow((f + 0.055f) / 1.055f, 2.4f);
		}

		public static float stbir__linear_to_srgb(float f)
		{
			if (f <= 0.0031308f)
				return f * 12.92f;
			return 1.055f * (float)CRuntime.pow(f, 1 / 2.4f) - 0.055f;
		}

		public static byte stbir__linear_to_srgb_uchar(float _in_)
		{
			var almostone = new stbir__FP32 { u = 0x3f7fffff };
			var minval = new stbir__FP32 { u = (127 - 13) << 23 };
			uint tab = 0;
			uint bias = 0;
			uint scale = 0;
			uint t = 0;
			var f = new stbir__FP32();
			if (!(_in_ > minval.f))
				_in_ = minval.f;
			if (_in_ > almostone.f)
				_in_ = almostone.f;
			f.f = _in_;
			tab = fp32_to_srgb8_tab4[(f.u - minval.u) >> 20];
			bias = (tab >> 16) << 9;
			scale = tab & 0xffff;
			t = (f.u >> 12) & 0xff;
			return (byte)((bias + scale * t) >> 16);
		}

		public static float stbir__filter_trapezoid(float x, float scale)
		{
			var halfscale = scale / 2;
			var t = 0.5f + halfscale;
			x = CRuntime.fabs(x);
			if (x >= t)
				return 0;

			var r = 0.5f - halfscale;
			if (x <= r)
				return 1;
			return (t - x) / scale;
		}

		public static float stbir__support_trapezoid(float scale)
		{
			return 0.5f + scale / 2;
		}

		public static float stbir__filter_triangle(float x, float s)
		{
			x = CRuntime.fabs(x);
			if (x <= 1.0f)
				return 1 - x;
			return 0;
		}

		public static float stbir__filter_cubic(float x, float s)
		{
			x = CRuntime.fabs(x);
			if (x < 1.0f)
				return (4 + x * x * (3 * x - 6)) / 6;
			if (x < 2.0f)
				return (8 + x * (-12 + x * (6 - x))) / 6;
			return 0.0f;
		}

		public static float stbir__filter_catmullrom(float x, float s)
		{
			x = CRuntime.fabs(x);
			if (x < 1.0f)
				return 1 - x * x * (2.5f - 1.5f * x);
			if (x < 2.0f)
				return 2 - x * (4 + x * (0.5f * x - 2.5f));
			return 0.0f;
		}

		public static float stbir__filter_mitchell(float x, float s)
		{
			x = CRuntime.fabs(x);
			if (x < 1.0f)
				return (16 + x * x * (21 * x - 36)) / 18;
			if (x < 2.0f)
				return (32 + x * (-60 + x * (36 - 7 * x))) / 18;
			return 0.0f;
		}

		public static float stbir__support_zero(float s)
		{
			return 0;
		}

		public static float stbir__support_one(float s)
		{
			return 1;
		}

		public static float stbir__support_two(float s)
		{
			return 2;
		}

		public static int stbir__use_upsampling(float ratio)
		{
			return ratio > 1 ? 1 : 0;
		}

		public static int stbir__use_width_upsampling(stbir__info* stbir_info)
		{
			return stbir__use_upsampling(stbir_info->horizontal_scale);
		}

		public static int stbir__use_height_upsampling(stbir__info* stbir_info)
		{
			return stbir__use_upsampling(stbir_info->vertical_scale);
		}

		public static int stbir__get_filter_pixel_width(int filter, float scale)
		{
			if (stbir__use_upsampling(scale) != 0)
				return (int)CRuntime.ceil(stbir__filter_info_table[filter].support(1 / scale) * 2);
			return (int)CRuntime.ceil(stbir__filter_info_table[filter].support(scale) * 2 / scale);
		}

		public static int stbir__get_filter_pixel_margin(int filter, float scale)
		{
			return stbir__get_filter_pixel_width(filter, scale) / 2;
		}

		public static int stbir__get_coefficient_width(int filter, float scale)
		{
			if (stbir__use_upsampling(scale) != 0)
				return (int)CRuntime.ceil(stbir__filter_info_table[filter].support(1 / scale) * 2);
			return (int)CRuntime.ceil(stbir__filter_info_table[filter].support(scale) * 2);
		}

		public static int stbir__get_contributors(float scale, int filter, int input_size, int output_size)
		{
			if (stbir__use_upsampling(scale) != 0)
				return output_size;
			return input_size + stbir__get_filter_pixel_margin(filter, scale) * 2;
		}

		public static int stbir__get_total_horizontal_coefficients(stbir__info* info)
		{
			return info->horizontal_num_contributors *
				   stbir__get_coefficient_width(info->horizontal_filter, info->horizontal_scale);
		}

		public static int stbir__get_total_vertical_coefficients(stbir__info* info)
		{
			return info->vertical_num_contributors *
				   stbir__get_coefficient_width(info->vertical_filter, info->vertical_scale);
		}

		public static stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)
		{
			return &contributors[n];
		}

		public static float* stbir__get_coefficient(float* coefficients, int filter, float scale, int n, int c)
		{
			var width = stbir__get_coefficient_width(filter, scale);
			return &coefficients[width * n + c];
		}

		public static int stbir__edge_wrap_slow(int edge, int n, int max)
		{
			switch (edge)
			{
				case STBIR_EDGE_ZERO:
					return 0;
				case STBIR_EDGE_CLAMP:
					if (n < 0)
						return 0;
					if (n >= max)
						return max - 1;
					return n;
				case STBIR_EDGE_REFLECT:
				{
					if (n < 0)
					{
						if (n < max)
							return -n;
						return max - 1;
					}

					if (n >= max)
					{
						var max2 = max * 2;
						if (n >= max2)
							return 0;
						return max2 - n - 1;
					}

					return n;
				}
				case STBIR_EDGE_WRAP:
					if (n >= 0)
					{
						return n % max;
					}
					else
					{
						var m = -n % max;
						if (m != 0)
							m = max - m;
						return m;
					}
				default:
					;
					return 0;
			}
		}

		public static int stbir__edge_wrap(int edge, int n, int max)
		{
			if (n >= 0 && n < max)
				return n;
			return stbir__edge_wrap_slow(edge, n, max);
		}

		public static void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio,
			float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)
		{
			var out_pixel_center = n + 0.5f;
			var out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius;
			var out_pixel_influence_upperbound = out_pixel_center + out_filter_radius;
			var in_pixel_influence_lowerbound = (out_pixel_influence_lowerbound + out_shift) / scale_ratio;
			var in_pixel_influence_upperbound = (out_pixel_influence_upperbound + out_shift) / scale_ratio;
			*in_center_of_out = (out_pixel_center + out_shift) / scale_ratio;
			*in_first_pixel = (int)CRuntime.floor(in_pixel_influence_lowerbound + 0.5);
			*in_last_pixel = (int)CRuntime.floor(in_pixel_influence_upperbound - 0.5);
		}

		public static void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio,
			float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)
		{
			var in_pixel_center = n + 0.5f;
			var in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius;
			var in_pixel_influence_upperbound = in_pixel_center + in_pixels_radius;
			var out_pixel_influence_lowerbound = in_pixel_influence_lowerbound * scale_ratio - out_shift;
			var out_pixel_influence_upperbound = in_pixel_influence_upperbound * scale_ratio - out_shift;
			*out_center_of_in = in_pixel_center * scale_ratio - out_shift;
			*out_first_pixel = (int)CRuntime.floor(out_pixel_influence_lowerbound + 0.5);
			*out_last_pixel = (int)CRuntime.floor(out_pixel_influence_upperbound - 0.5);
		}

		public static void stbir__calculate_coefficients_upsample(int filter, float scale, int in_first_pixel,
			int in_last_pixel, float in_center_of_out, stbir__contributors* contributor, float* coefficient_group)
		{
			var i = 0;
			var total_filter = (float)0;
			float filter_scale = 0;
			contributor->n0 = in_first_pixel;
			contributor->n1 = in_last_pixel;
			for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
			{
				var in_pixel_center = i + in_first_pixel + 0.5f;
				coefficient_group[i] = stbir__filter_info_table[filter]
					.kernel(in_center_of_out - in_pixel_center, 1 / scale);
				if (i == 0 && coefficient_group[i] == 0)
				{
					contributor->n0 = ++in_first_pixel;
					i--;
					continue;
				}

				total_filter += coefficient_group[i];
			}

			filter_scale = 1 / total_filter;
			for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
				coefficient_group[i] *= filter_scale;
			for (i = in_last_pixel - in_first_pixel; i >= 0; i--)
			{
				if (coefficient_group[i] != 0)
					break;
				contributor->n1 = contributor->n0 + i - 1;
			}
		}

		public static void stbir__calculate_coefficients_downsample(int filter, float scale_ratio, int out_first_pixel,
			int out_last_pixel, float out_center_of_in, stbir__contributors* contributor, float* coefficient_group)
		{
			var i = 0;
			contributor->n0 = out_first_pixel;
			contributor->n1 = out_last_pixel;
			for (i = 0; i <= out_last_pixel - out_first_pixel; i++)
			{
				var out_pixel_center = i + out_first_pixel + 0.5f;
				var x = out_pixel_center - out_center_of_in;
				coefficient_group[i] = stbir__filter_info_table[filter].kernel(x, scale_ratio) * scale_ratio;
			}

			for (i = out_last_pixel - out_first_pixel; i >= 0; i--)
			{
				if (coefficient_group[i] != 0)
					break;
				contributor->n1 = contributor->n0 + i - 1;
			}
		}

		public static void stbir__normalize_downsample_coefficients(stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, int input_size, int output_size)
		{
			var num_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);
			var num_coefficients = stbir__get_coefficient_width(filter, scale_ratio);
			var i = 0;
			var j = 0;
			var skip = 0;
			for (i = 0; i < output_size; i++)
			{
				float scale = 0;
				var total = (float)0;
				for (j = 0; j < num_contributors; j++)
					if (i >= contributors[j].n0 && i <= contributors[j].n1)
					{
						var coefficient = *stbir__get_coefficient(coefficients, filter, scale_ratio, j,
							i - contributors[j].n0);
						total += coefficient;
					}
					else if (i < contributors[j].n0)
					{
						break;
					}

				scale = 1 / total;
				for (j = 0; j < num_contributors; j++)
					if (i >= contributors[j].n0 && i <= contributors[j].n1)
						*stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0) *= scale;
					else if (i < contributors[j].n0)
						break;
			}

			for (j = 0; j < num_contributors; j++)
			{
				var range = 0;
				var max = 0;
				var width = 0;
				skip = 0;
				while (*stbir__get_coefficient(coefficients, filter, scale_ratio, j, skip) == 0)
					skip++;
				contributors[j].n0 += skip;
				while (contributors[j].n0 < 0)
				{
					contributors[j].n0++;
					skip++;
				}

				range = contributors[j].n1 - contributors[j].n0 + 1;
				max = stbir__min(num_coefficients, range);
				width = stbir__get_coefficient_width(filter, scale_ratio);
				for (i = 0; i < max; i++)
				{
					if (i + skip >= width)
						break;
					*stbir__get_coefficient(coefficients, filter, scale_ratio, j, i) =
						*stbir__get_coefficient(coefficients, filter, scale_ratio, j, i + skip);
				}
			}

			for (i = 0; i < num_contributors; i++)
				contributors[i].n1 = stbir__min(contributors[i].n1, output_size - 1);
		}

		public static void stbir__calculate_filters(stbir__contributors* contributors, float* coefficients, int filter,
			float scale_ratio, float shift, int input_size, int output_size)
		{
			var n = 0;
			var total_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);
			if (stbir__use_upsampling(scale_ratio) != 0)
			{
				var out_pixels_radius = stbir__filter_info_table[filter].support(1 / scale_ratio) * scale_ratio;
				for (n = 0; n < total_contributors; n++)
				{
					float in_center_of_out = 0;
					var in_first_pixel = 0;
					var in_last_pixel = 0;
					stbir__calculate_sample_range_upsample(n, out_pixels_radius, scale_ratio, shift, &in_first_pixel,
						&in_last_pixel, &in_center_of_out);
					stbir__calculate_coefficients_upsample(filter, scale_ratio, in_first_pixel, in_last_pixel,
						in_center_of_out, stbir__get_contributor(contributors, n),
						stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));
				}
			}
			else
			{
				var in_pixels_radius = stbir__filter_info_table[filter].support(scale_ratio) / scale_ratio;
				for (n = 0; n < total_contributors; n++)
				{
					float out_center_of_in = 0;
					var out_first_pixel = 0;
					var out_last_pixel = 0;
					var n_adjusted = n - stbir__get_filter_pixel_margin(filter, scale_ratio);
					stbir__calculate_sample_range_downsample(n_adjusted, in_pixels_radius, scale_ratio, shift,
						&out_first_pixel, &out_last_pixel, &out_center_of_in);
					stbir__calculate_coefficients_downsample(filter, scale_ratio, out_first_pixel, out_last_pixel,
						out_center_of_in, stbir__get_contributor(contributors, n),
						stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));
				}

				stbir__normalize_downsample_coefficients(contributors, coefficients, filter, scale_ratio, input_size,
					output_size);
			}
		}

		public static float* stbir__get_decode_buffer(stbir__info* stbir_info)
		{
			return &stbir_info->decode_buffer[stbir_info->horizontal_filter_pixel_margin * stbir_info->channels];
		}

		public static void stbir__decode_scanline(stbir__info* stbir_info, int n)
		{
			var c = 0;
			var channels = stbir_info->channels;
			var alpha_channel = stbir_info->alpha_channel;
			var type = stbir_info->type;
			var colorspace = stbir_info->colorspace;
			var input_w = stbir_info->input_w;
			var input_stride_bytes = stbir_info->input_stride_bytes;
			var decode_buffer = stbir__get_decode_buffer(stbir_info);
			var edge_horizontal = stbir_info->edge_horizontal;
			var edge_vertical = stbir_info->edge_vertical;
			var in_buffer_row_offset =
				(ulong)(stbir__edge_wrap(edge_vertical, n, stbir_info->input_h) * input_stride_bytes);
			void* input_data = (sbyte*)stbir_info->input_data + in_buffer_row_offset;
			var max_x = input_w + stbir_info->horizontal_filter_pixel_margin;
			var decode = type * STBIR_MAX_COLORSPACES + colorspace;
			var x = -stbir_info->horizontal_filter_pixel_margin;
			if (edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->input_h))
			{
				for (; x < max_x; x++)
					for (c = 0; c < channels; c++)
						decode_buffer[x * channels + c] = 0;
				return;
			}

			switch (decode)
			{
				case STBIR_TYPE_UINT8 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								((byte*)input_data)[input_pixel_index + c] / stbir__max_uint8_as_float;
					}

					break;
				case STBIR_TYPE_UINT8 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								stbir__srgb_uchar_to_linear_float[((byte*)input_data)[input_pixel_index + c]];
						if ((stbir_info->flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								((byte*)input_data)[input_pixel_index + alpha_channel] / stbir__max_uint8_as_float;
					}

					break;
				case STBIR_TYPE_UINT16 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								((ushort*)input_data)[input_pixel_index + c] / stbir__max_uint16_as_float;
					}

					break;
				case STBIR_TYPE_UINT16 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								stbir__srgb_to_linear(((ushort*)input_data)[input_pixel_index + c] /
													  stbir__max_uint16_as_float);
						if ((stbir_info->flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								((ushort*)input_data)[input_pixel_index + alpha_channel] / stbir__max_uint16_as_float;
					}

					break;
				case STBIR_TYPE_UINT32 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								(float)(((uint*)input_data)[input_pixel_index + c] / stbir__max_uint32_as_float);
					}

					break;
				case STBIR_TYPE_UINT32 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear(
								(float)(((uint*)input_data)[input_pixel_index + c] / stbir__max_uint32_as_float));
						if ((stbir_info->flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								(float)(((uint*)input_data)[input_pixel_index + alpha_channel] /
										 stbir__max_uint32_as_float);
					}

					break;
				case STBIR_TYPE_FLOAT * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] = ((float*)input_data)[input_pixel_index + c];
					}

					break;
				case STBIR_TYPE_FLOAT * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (; x < max_x; x++)
					{
						var decode_pixel_index = x * channels;
						var input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
						for (c = 0; c < channels; c++)
							decode_buffer[decode_pixel_index + c] =
								stbir__srgb_to_linear(((float*)input_data)[input_pixel_index + c]);
						if ((stbir_info->flags & (1 << 1)) == 0)
							decode_buffer[decode_pixel_index + alpha_channel] =
								((float*)input_data)[input_pixel_index + alpha_channel];
					}

					break;
				default:
					;
					break;
			}

			if ((stbir_info->flags & (1 << 0)) == 0)
				for (x = -stbir_info->horizontal_filter_pixel_margin; x < max_x; x++)
				{
					var decode_pixel_index = x * channels;
					var alpha = decode_buffer[decode_pixel_index + alpha_channel];
					if (stbir_info->type != STBIR_TYPE_FLOAT)
					{
						alpha += (float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20);
						decode_buffer[decode_pixel_index + alpha_channel] = alpha;
					}

					for (c = 0; c < channels; c++)
					{
						if (c == alpha_channel)
							continue;
						decode_buffer[decode_pixel_index + c] *= alpha;
					}
				}

			if (edge_horizontal == STBIR_EDGE_ZERO)
			{
				for (x = -stbir_info->horizontal_filter_pixel_margin; x < 0; x++)
					for (c = 0; c < channels; c++)
						decode_buffer[x * channels + c] = 0;
				for (x = input_w; x < max_x; x++)
					for (c = 0; c < channels; c++)
						decode_buffer[x * channels + c] = 0;
			}
		}

		public static float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)
		{
			return &ring_buffer[index * ring_buffer_length];
		}

		public static float* stbir__add_empty_ring_buffer_entry(stbir__info* stbir_info, int n)
		{
			var ring_buffer_index = 0;
			float* ring_buffer;
			stbir_info->ring_buffer_last_scanline = n;
			if (stbir_info->ring_buffer_begin_index < 0)
			{
				ring_buffer_index = stbir_info->ring_buffer_begin_index = 0;
				stbir_info->ring_buffer_first_scanline = n;
			}
			else
			{
				ring_buffer_index =
					(stbir_info->ring_buffer_begin_index +
					 (stbir_info->ring_buffer_last_scanline - stbir_info->ring_buffer_first_scanline)) %
					stbir_info->ring_buffer_num_entries;
			}

			ring_buffer = stbir__get_ring_buffer_entry(stbir_info->ring_buffer, ring_buffer_index,
				stbir_info->ring_buffer_length_bytes / sizeof(float));
			CRuntime.memset(ring_buffer, 0, (ulong)stbir_info->ring_buffer_length_bytes);
			return ring_buffer;
		}

		public static void stbir__resample_horizontal_upsample(stbir__info* stbir_info, float* output_buffer)
		{
			var x = 0;
			var k = 0;
			var output_w = stbir_info->output_w;
			var channels = stbir_info->channels;
			var decode_buffer = stbir__get_decode_buffer(stbir_info);
			var horizontal_contributors = stbir_info->horizontal_contributors;
			var horizontal_coefficients = stbir_info->horizontal_coefficients;
			var coefficient_width = stbir_info->horizontal_coefficient_width;
			for (x = 0; x < output_w; x++)
			{
				var n0 = horizontal_contributors[x].n0;
				var n1 = horizontal_contributors[x].n1;
				var out_pixel_index = x * channels;
				var coefficient_group = coefficient_width * x;
				var coefficient_counter = 0;
				switch (channels)
				{
					case 1:
						for (k = n0; k <= n1; k++)
						{
							var in_pixel_index = k * 1;
							var coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
						}

						break;
					case 2:
						for (k = n0; k <= n1; k++)
						{
							var in_pixel_index = k * 2;
							var coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
						}

						break;
					case 3:
						for (k = n0; k <= n1; k++)
						{
							var in_pixel_index = k * 3;
							var coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
							output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
						}

						break;
					case 4:
						for (k = n0; k <= n1; k++)
						{
							var in_pixel_index = k * 4;
							var coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
							output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
							output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;
						}

						break;
					default:
						for (k = n0; k <= n1; k++)
						{
							var in_pixel_index = k * channels;
							var coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
							var c = 0;
							for (c = 0; c < channels; c++)
								output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;
						}

						break;
				}
			}
		}

		public static void stbir__resample_horizontal_downsample(stbir__info* stbir_info, float* output_buffer)
		{
			var x = 0;
			var k = 0;
			var input_w = stbir_info->input_w;
			var channels = stbir_info->channels;
			var decode_buffer = stbir__get_decode_buffer(stbir_info);
			var horizontal_contributors = stbir_info->horizontal_contributors;
			var horizontal_coefficients = stbir_info->horizontal_coefficients;
			var coefficient_width = stbir_info->horizontal_coefficient_width;
			var filter_pixel_margin = stbir_info->horizontal_filter_pixel_margin;
			var max_x = input_w + filter_pixel_margin * 2;
			switch (channels)
			{
				case 1:
					for (x = 0; x < max_x; x++)
					{
						var n0 = horizontal_contributors[x].n0;
						var n1 = horizontal_contributors[x].n1;
						var in_x = x - filter_pixel_margin;
						var in_pixel_index = in_x * 1;
						var max_n = n1;
						var coefficient_group = coefficient_width * x;
						for (k = n0; k <= max_n; k++)
						{
							var out_pixel_index = k * 1;
							var coefficient = horizontal_coefficients[coefficient_group + k - n0];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
						}
					}

					break;
				case 2:
					for (x = 0; x < max_x; x++)
					{
						var n0 = horizontal_contributors[x].n0;
						var n1 = horizontal_contributors[x].n1;
						var in_x = x - filter_pixel_margin;
						var in_pixel_index = in_x * 2;
						var max_n = n1;
						var coefficient_group = coefficient_width * x;
						for (k = n0; k <= max_n; k++)
						{
							var out_pixel_index = k * 2;
							var coefficient = horizontal_coefficients[coefficient_group + k - n0];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
						}
					}

					break;
				case 3:
					for (x = 0; x < max_x; x++)
					{
						var n0 = horizontal_contributors[x].n0;
						var n1 = horizontal_contributors[x].n1;
						var in_x = x - filter_pixel_margin;
						var in_pixel_index = in_x * 3;
						var max_n = n1;
						var coefficient_group = coefficient_width * x;
						for (k = n0; k <= max_n; k++)
						{
							var out_pixel_index = k * 3;
							var coefficient = horizontal_coefficients[coefficient_group + k - n0];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
							output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
						}
					}

					break;
				case 4:
					for (x = 0; x < max_x; x++)
					{
						var n0 = horizontal_contributors[x].n0;
						var n1 = horizontal_contributors[x].n1;
						var in_x = x - filter_pixel_margin;
						var in_pixel_index = in_x * 4;
						var max_n = n1;
						var coefficient_group = coefficient_width * x;
						for (k = n0; k <= max_n; k++)
						{
							var out_pixel_index = k * 4;
							var coefficient = horizontal_coefficients[coefficient_group + k - n0];
							output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
							output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
							output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
							output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;
						}
					}

					break;
				default:
					for (x = 0; x < max_x; x++)
					{
						var n0 = horizontal_contributors[x].n0;
						var n1 = horizontal_contributors[x].n1;
						var in_x = x - filter_pixel_margin;
						var in_pixel_index = in_x * channels;
						var max_n = n1;
						var coefficient_group = coefficient_width * x;
						for (k = n0; k <= max_n; k++)
						{
							var c = 0;
							var out_pixel_index = k * channels;
							var coefficient = horizontal_coefficients[coefficient_group + k - n0];
							for (c = 0; c < channels; c++)
								output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;
						}
					}

					break;
			}
		}

		public static void stbir__decode_and_resample_upsample(stbir__info* stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, n);
			if (stbir__use_width_upsampling(stbir_info) != 0)
				stbir__resample_horizontal_upsample(stbir_info, stbir__add_empty_ring_buffer_entry(stbir_info, n));
			else
				stbir__resample_horizontal_downsample(stbir_info, stbir__add_empty_ring_buffer_entry(stbir_info, n));
		}

		public static void stbir__decode_and_resample_downsample(stbir__info* stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, n);
			CRuntime.memset(stbir_info->horizontal_buffer, 0,
				(ulong)(stbir_info->output_w * stbir_info->channels * sizeof(float)));
			if (stbir__use_width_upsampling(stbir_info) != 0)
				stbir__resample_horizontal_upsample(stbir_info, stbir_info->horizontal_buffer);
			else
				stbir__resample_horizontal_downsample(stbir_info, stbir_info->horizontal_buffer);
		}

		public static float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index,
			int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
		{
			var ring_buffer_index = (begin_index + (get_scanline - first_scanline)) % ring_buffer_num_entries;
			return stbir__get_ring_buffer_entry(ring_buffer, ring_buffer_index, ring_buffer_length);
		}

		public static void stbir__encode_scanline(stbir__info* stbir_info, int num_pixels, void* output_buffer,
			float* encode_buffer, int channels, int alpha_channel, int decode)
		{
			var x = 0;
			var n = 0;
			var num_nonalpha = 0;
			var nonalpha = stackalloc ushort[64];
			if ((stbir_info->flags & (1 << 0)) == 0)
				for (x = 0; x < num_pixels; ++x)
				{
					var pixel_index = x * channels;
					var alpha = encode_buffer[pixel_index + alpha_channel];
					var reciprocal_alpha = alpha != 0 ? 1.0f / alpha : 0;
					for (n = 0; n < channels; n++)
						if (n != alpha_channel)
							encode_buffer[pixel_index + n] *= reciprocal_alpha;
				}

			for (x = 0, num_nonalpha = 0; x < channels; ++x)
				if (x != alpha_channel || (stbir_info->flags & (1 << 1)) != 0)
					nonalpha[num_nonalpha++] = (ushort)x;
			switch (decode)
			{
				case STBIR_TYPE_UINT8 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < channels; n++)
						{
							var index = pixel_index + n;
							((byte*)output_buffer)[index] =
								(byte)(int)(stbir__saturate(encode_buffer[index]) * stbir__max_uint8_as_float + 0.5);
						}
					}

					break;
				case STBIR_TYPE_UINT8 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < num_nonalpha; n++)
						{
							var index = pixel_index + nonalpha[n];
							((byte*)output_buffer)[index] = stbir__linear_to_srgb_uchar(encode_buffer[index]);
						}

						if ((stbir_info->flags & (1 << 1)) == 0)
							((byte*)output_buffer)[pixel_index + alpha_channel] =
								(byte)(int)(stbir__saturate(encode_buffer[pixel_index + alpha_channel]) *
									stbir__max_uint8_as_float + 0.5);
					}

					break;
				case STBIR_TYPE_UINT16 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < channels; n++)
						{
							var index = pixel_index + n;
							((ushort*)output_buffer)[index] =
								(ushort)(int)(stbir__saturate(encode_buffer[index]) * stbir__max_uint16_as_float +
												0.5);
						}
					}

					break;
				case STBIR_TYPE_UINT16 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < num_nonalpha; n++)
						{
							var index = pixel_index + nonalpha[n];
							((ushort*)output_buffer)[index] =
								(ushort)(int)(stbir__linear_to_srgb(stbir__saturate(encode_buffer[index])) *
									stbir__max_uint16_as_float + 0.5);
						}

						if ((stbir_info->flags & (1 << 1)) == 0)
							((ushort*)output_buffer)[pixel_index + alpha_channel] =
								(ushort)(int)(stbir__saturate(encode_buffer[pixel_index + alpha_channel]) *
									stbir__max_uint16_as_float + 0.5);
					}

					break;
				case STBIR_TYPE_UINT32 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < channels; n++)
						{
							var index = pixel_index + n;
							((uint*)output_buffer)[index] =
								(uint)(stbir__saturate(encode_buffer[index]) * stbir__max_uint32_as_float + 0.5);
						}
					}

					break;
				case STBIR_TYPE_UINT32 * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < num_nonalpha; n++)
						{
							var index = pixel_index + nonalpha[n];
							((uint*)output_buffer)[index] =
								(uint)(stbir__linear_to_srgb(stbir__saturate(encode_buffer[index])) *
									stbir__max_uint32_as_float + 0.5);
						}

						if ((stbir_info->flags & (1 << 1)) == 0)
							((uint*)output_buffer)[pixel_index + alpha_channel] =
								(uint)(int)(stbir__saturate(encode_buffer[pixel_index + alpha_channel]) *
									stbir__max_uint32_as_float + 0.5);
					}

					break;
				case STBIR_TYPE_FLOAT * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_LINEAR:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < channels; n++)
						{
							var index = pixel_index + n;
							((float*)output_buffer)[index] = encode_buffer[index];
						}
					}

					break;
				case STBIR_TYPE_FLOAT * STBIR_MAX_COLORSPACES + STBIR_COLORSPACE_SRGB:
					for (x = 0; x < num_pixels; ++x)
					{
						var pixel_index = x * channels;
						for (n = 0; n < num_nonalpha; n++)
						{
							var index = pixel_index + nonalpha[n];
							((float*)output_buffer)[index] = stbir__linear_to_srgb(encode_buffer[index]);
						}

						if ((stbir_info->flags & (1 << 1)) == 0)
							((float*)output_buffer)[pixel_index + alpha_channel] =
								encode_buffer[pixel_index + alpha_channel];
					}

					break;
				default:
					;
					break;
			}
		}

		public static void stbir__resample_vertical_upsample(stbir__info* stbir_info, int n)
		{
			var x = 0;
			var k = 0;
			var output_w = stbir_info->output_w;
			var vertical_contributors = stbir_info->vertical_contributors;
			var vertical_coefficients = stbir_info->vertical_coefficients;
			var channels = stbir_info->channels;
			var alpha_channel = stbir_info->alpha_channel;
			var type = stbir_info->type;
			var colorspace = stbir_info->colorspace;
			var ring_buffer_entries = stbir_info->ring_buffer_num_entries;
			var output_data = stbir_info->output_data;
			var encode_buffer = stbir_info->encode_buffer;
			var decode = type * STBIR_MAX_COLORSPACES + colorspace;
			var coefficient_width = stbir_info->vertical_coefficient_width;
			var coefficient_counter = 0;
			var contributor = n;
			var ring_buffer = stbir_info->ring_buffer;
			var ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
			var ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
			var ring_buffer_length = stbir_info->ring_buffer_length_bytes / sizeof(float);
			var n0 = 0;
			var n1 = 0;
			var output_row_start = 0;
			var coefficient_group = coefficient_width * contributor;
			n0 = vertical_contributors[contributor].n0;
			n1 = vertical_contributors[contributor].n1;
			output_row_start = n * stbir_info->output_stride_bytes;
			CRuntime.memset(encode_buffer, 0, (ulong)(output_w * sizeof(float) * channels));
			coefficient_counter = 0;
			switch (channels)
			{
				case 1:
					for (k = n0; k <= n1; k++)
					{
						var coefficient_index = coefficient_counter++;
						var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
							ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
						var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
						for (x = 0; x < output_w; ++x)
						{
							var in_pixel_index = x * 1;
							encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
						}
					}

					break;
				case 2:
					for (k = n0; k <= n1; k++)
					{
						var coefficient_index = coefficient_counter++;
						var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
							ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
						var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
						for (x = 0; x < output_w; ++x)
						{
							var in_pixel_index = x * 2;
							encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
							encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
						}
					}

					break;
				case 3:
					for (k = n0; k <= n1; k++)
					{
						var coefficient_index = coefficient_counter++;
						var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
							ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
						var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
						for (x = 0; x < output_w; ++x)
						{
							var in_pixel_index = x * 3;
							encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
							encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
							encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
						}
					}

					break;
				case 4:
					for (k = n0; k <= n1; k++)
					{
						var coefficient_index = coefficient_counter++;
						var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
							ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
						var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
						for (x = 0; x < output_w; ++x)
						{
							var in_pixel_index = x * 4;
							encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
							encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
							encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
							encode_buffer[in_pixel_index + 3] += ring_buffer_entry[in_pixel_index + 3] * coefficient;
						}
					}

					break;
				default:
					for (k = n0; k <= n1; k++)
					{
						var coefficient_index = coefficient_counter++;
						var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
							ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
						var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
						for (x = 0; x < output_w; ++x)
						{
							var in_pixel_index = x * channels;
							var c = 0;
							for (c = 0; c < channels; c++)
								encode_buffer[in_pixel_index + c] +=
									ring_buffer_entry[in_pixel_index + c] * coefficient;
						}
					}

					break;
			}

			stbir__encode_scanline(stbir_info, output_w, (sbyte*)output_data + output_row_start, encode_buffer,
				channels, alpha_channel, decode);
		}

		public static void stbir__resample_vertical_downsample(stbir__info* stbir_info, int n)
		{
			var x = 0;
			var k = 0;
			var output_w = stbir_info->output_w;
			var vertical_contributors = stbir_info->vertical_contributors;
			var vertical_coefficients = stbir_info->vertical_coefficients;
			var channels = stbir_info->channels;
			var ring_buffer_entries = stbir_info->ring_buffer_num_entries;
			var horizontal_buffer = stbir_info->horizontal_buffer;
			var coefficient_width = stbir_info->vertical_coefficient_width;
			var contributor = n + stbir_info->vertical_filter_pixel_margin;
			var ring_buffer = stbir_info->ring_buffer;
			var ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
			var ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
			var ring_buffer_length = stbir_info->ring_buffer_length_bytes / sizeof(float);
			var n0 = 0;
			var n1 = 0;
			n0 = vertical_contributors[contributor].n0;
			n1 = vertical_contributors[contributor].n1;
			for (k = n0; k <= n1; k++)
			{
				var coefficient_index = k - n0;
				var coefficient_group = coefficient_width * contributor;
				var coefficient = vertical_coefficients[coefficient_group + coefficient_index];
				var ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index,
					ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
				switch (channels)
				{
					case 1:
						for (x = 0; x < output_w; x++)
						{
							var in_pixel_index = x * 1;
							ring_buffer_entry[in_pixel_index + 0] +=
								horizontal_buffer[in_pixel_index + 0] * coefficient;
						}

						break;
					case 2:
						for (x = 0; x < output_w; x++)
						{
							var in_pixel_index = x * 2;
							ring_buffer_entry[in_pixel_index + 0] +=
								horizontal_buffer[in_pixel_index + 0] * coefficient;
							ring_buffer_entry[in_pixel_index + 1] +=
								horizontal_buffer[in_pixel_index + 1] * coefficient;
						}

						break;
					case 3:
						for (x = 0; x < output_w; x++)
						{
							var in_pixel_index = x * 3;
							ring_buffer_entry[in_pixel_index + 0] +=
								horizontal_buffer[in_pixel_index + 0] * coefficient;
							ring_buffer_entry[in_pixel_index + 1] +=
								horizontal_buffer[in_pixel_index + 1] * coefficient;
							ring_buffer_entry[in_pixel_index + 2] +=
								horizontal_buffer[in_pixel_index + 2] * coefficient;
						}

						break;
					case 4:
						for (x = 0; x < output_w; x++)
						{
							var in_pixel_index = x * 4;
							ring_buffer_entry[in_pixel_index + 0] +=
								horizontal_buffer[in_pixel_index + 0] * coefficient;
							ring_buffer_entry[in_pixel_index + 1] +=
								horizontal_buffer[in_pixel_index + 1] * coefficient;
							ring_buffer_entry[in_pixel_index + 2] +=
								horizontal_buffer[in_pixel_index + 2] * coefficient;
							ring_buffer_entry[in_pixel_index + 3] +=
								horizontal_buffer[in_pixel_index + 3] * coefficient;
						}

						break;
					default:
						for (x = 0; x < output_w; x++)
						{
							var in_pixel_index = x * channels;
							var c = 0;
							for (c = 0; c < channels; c++)
								ring_buffer_entry[in_pixel_index + c] +=
									horizontal_buffer[in_pixel_index + c] * coefficient;
						}

						break;
				}
			}
		}

		public static void stbir__buffer_loop_upsample(stbir__info* stbir_info)
		{
			var y = 0;
			var scale_ratio = stbir_info->vertical_scale;
			var out_scanlines_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(1 / scale_ratio) *
									   scale_ratio;
			for (y = 0; y < stbir_info->output_h; y++)
			{
				var in_center_of_out = (float)0;
				var in_first_scanline = 0;
				var in_last_scanline = 0;
				stbir__calculate_sample_range_upsample(y, out_scanlines_radius, scale_ratio, stbir_info->vertical_shift,
					&in_first_scanline, &in_last_scanline, &in_center_of_out);
				if (stbir_info->ring_buffer_begin_index >= 0)
					while (in_first_scanline > stbir_info->ring_buffer_first_scanline)
						if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
						{
							stbir_info->ring_buffer_begin_index = -1;
							stbir_info->ring_buffer_first_scanline = 0;
							stbir_info->ring_buffer_last_scanline = 0;
							break;
						}
						else
						{
							stbir_info->ring_buffer_first_scanline++;
							stbir_info->ring_buffer_begin_index =
								(stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
						}

				if (stbir_info->ring_buffer_begin_index < 0)
					stbir__decode_and_resample_upsample(stbir_info, in_first_scanline);
				while (in_last_scanline > stbir_info->ring_buffer_last_scanline)
					stbir__decode_and_resample_upsample(stbir_info, stbir_info->ring_buffer_last_scanline + 1);
				stbir__resample_vertical_upsample(stbir_info, y);
			}
		}

		public static void stbir__empty_ring_buffer(stbir__info* stbir_info, int first_necessary_scanline)
		{
			var output_stride_bytes = stbir_info->output_stride_bytes;
			var channels = stbir_info->channels;
			var alpha_channel = stbir_info->alpha_channel;
			var type = stbir_info->type;
			var colorspace = stbir_info->colorspace;
			var output_w = stbir_info->output_w;
			var output_data = stbir_info->output_data;
			var decode = type * STBIR_MAX_COLORSPACES + colorspace;
			var ring_buffer = stbir_info->ring_buffer;
			var ring_buffer_length = stbir_info->ring_buffer_length_bytes / sizeof(float);
			if (stbir_info->ring_buffer_begin_index >= 0)
				while (first_necessary_scanline > stbir_info->ring_buffer_first_scanline)
				{
					if (stbir_info->ring_buffer_first_scanline >= 0 &&
						stbir_info->ring_buffer_first_scanline < stbir_info->output_h)
					{
						var output_row_start = stbir_info->ring_buffer_first_scanline * output_stride_bytes;
						var ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer,
							stbir_info->ring_buffer_begin_index, ring_buffer_length);
						stbir__encode_scanline(stbir_info, output_w, (sbyte*)output_data + output_row_start,
							ring_buffer_entry, channels, alpha_channel, decode);
					}

					if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
					{
						stbir_info->ring_buffer_begin_index = -1;
						stbir_info->ring_buffer_first_scanline = 0;
						stbir_info->ring_buffer_last_scanline = 0;
						break;
					}

					stbir_info->ring_buffer_first_scanline++;
					stbir_info->ring_buffer_begin_index =
						(stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
				}
		}

		public static void stbir__buffer_loop_downsample(stbir__info* stbir_info)
		{
			var y = 0;
			var scale_ratio = stbir_info->vertical_scale;
			var output_h = stbir_info->output_h;
			var in_pixels_radius =
				stbir__filter_info_table[stbir_info->vertical_filter].support(scale_ratio) / scale_ratio;
			var pixel_margin = stbir_info->vertical_filter_pixel_margin;
			var max_y = stbir_info->input_h + pixel_margin;
			for (y = -pixel_margin; y < max_y; y++)
			{
				float out_center_of_in = 0;
				var out_first_scanline = 0;
				var out_last_scanline = 0;
				stbir__calculate_sample_range_downsample(y, in_pixels_radius, scale_ratio, stbir_info->vertical_shift,
					&out_first_scanline, &out_last_scanline, &out_center_of_in);
				if (out_last_scanline < 0 || out_first_scanline >= output_h)
					continue;
				stbir__empty_ring_buffer(stbir_info, out_first_scanline);
				stbir__decode_and_resample_downsample(stbir_info, y);
				if (stbir_info->ring_buffer_begin_index < 0)
					stbir__add_empty_ring_buffer_entry(stbir_info, out_first_scanline);
				while (out_last_scanline > stbir_info->ring_buffer_last_scanline)
					stbir__add_empty_ring_buffer_entry(stbir_info, stbir_info->ring_buffer_last_scanline + 1);
				stbir__resample_vertical_downsample(stbir_info, y);
			}

			stbir__empty_ring_buffer(stbir_info, stbir_info->output_h);
		}

		public static void stbir__setup(stbir__info* info, int input_w, int input_h, int output_w, int output_h,
			int channels)
		{
			info->input_w = input_w;
			info->input_h = input_h;
			info->output_w = output_w;
			info->output_h = output_h;
			info->channels = channels;
		}

		public static void stbir__calculate_transform(stbir__info* info, float s0, float t0, float s1, float t1,
			float* transform)
		{
			info->s0 = s0;
			info->t0 = t0;
			info->s1 = s1;
			info->t1 = t1;
			if (transform != null)
			{
				info->horizontal_scale = transform[0];
				info->vertical_scale = transform[1];
				info->horizontal_shift = transform[2];
				info->vertical_shift = transform[3];
			}
			else
			{
				info->horizontal_scale = (float)info->output_w / info->input_w / (s1 - s0);
				info->vertical_scale = (float)info->output_h / info->input_h / (t1 - t0);
				info->horizontal_shift = s0 * info->output_w / (s1 - s0);
				info->vertical_shift = t0 * info->output_h / (t1 - t0);
			}
		}

		public static void stbir__choose_filter(stbir__info* info, int h_filter, int v_filter)
		{
			if (h_filter == 0)
				h_filter = stbir__use_upsampling(info->horizontal_scale) != 0
					? STBIR_FILTER_CATMULLROM
					: STBIR_FILTER_MITCHELL;
			if (v_filter == 0)
				v_filter = stbir__use_upsampling(info->vertical_scale) != 0
					? STBIR_FILTER_CATMULLROM
					: STBIR_FILTER_MITCHELL;
			info->horizontal_filter = h_filter;
			info->vertical_filter = v_filter;
		}

		public static uint stbir__calculate_memory(stbir__info* info)
		{
			var pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
			var filter_height = stbir__get_filter_pixel_width(info->vertical_filter, info->vertical_scale);
			info->horizontal_num_contributors = stbir__get_contributors(info->horizontal_scale, info->horizontal_filter,
				info->input_w, info->output_w);
			info->vertical_num_contributors = stbir__get_contributors(info->vertical_scale, info->vertical_filter,
				info->input_h, info->output_h);
			info->ring_buffer_num_entries = filter_height + 1;
			info->horizontal_contributors_size = info->horizontal_num_contributors * sizeof(stbir__contributors);
			info->horizontal_coefficients_size = stbir__get_total_horizontal_coefficients(info) * sizeof(float);
			info->vertical_contributors_size = info->vertical_num_contributors * sizeof(stbir__contributors);
			info->vertical_coefficients_size = stbir__get_total_vertical_coefficients(info) * sizeof(float);
			info->decode_buffer_size = (info->input_w + pixel_margin * 2) * info->channels * sizeof(float);
			info->horizontal_buffer_size = info->output_w * info->channels * sizeof(float);
			info->ring_buffer_size = info->output_w * info->channels * info->ring_buffer_num_entries * sizeof(float);
			info->encode_buffer_size = info->output_w * info->channels * sizeof(float);
			if (stbir__use_height_upsampling(info) != 0)
				info->horizontal_buffer_size = 0;
			else
				info->encode_buffer_size = 0;
			return (uint)(info->horizontal_contributors_size + info->horizontal_coefficients_size +
						   info->vertical_contributors_size + info->vertical_coefficients_size +
						   info->decode_buffer_size + info->horizontal_buffer_size + info->ring_buffer_size +
						   info->encode_buffer_size);
		}

		public static int stbir__resize_allocated(stbir__info* info, void* input_data, int input_stride_in_bytes,
			void* output_data, int output_stride_in_bytes, int alpha_channel, uint flags, int type, int edge_horizontal,
			int edge_vertical, int colorspace, void* tempmem, ulong tempmem_size_in_bytes)
		{
			var memory_required = (ulong)stbir__calculate_memory(info);
			var width_stride_input = input_stride_in_bytes != 0
				? input_stride_in_bytes
				: info->channels * info->input_w * stbir__type_size[type];
			var width_stride_output = output_stride_in_bytes != 0
				? output_stride_in_bytes
				: info->channels * info->output_w * stbir__type_size[type];
			if (info->channels < 0 || info->channels > 64)
				return 0;
			if (info->horizontal_filter >= stbir__filter_info_table.Length)
				return 0;
			if (info->vertical_filter >= stbir__filter_info_table.Length)
				return 0;
			if (alpha_channel < 0)
				flags |= (1 << 1) | (1 << 0);
			if ((flags & (1 << 1)) == 0 || (flags & (1 << 0)) == 0)
			{
			}

			if (alpha_channel >= info->channels)
				return 0;
			if (tempmem == null)
				return 0;
			if (tempmem_size_in_bytes < memory_required)
				return 0;
			CRuntime.memset(tempmem, 0, tempmem_size_in_bytes);
			info->input_data = input_data;
			info->input_stride_bytes = width_stride_input;
			info->output_data = output_data;
			info->output_stride_bytes = width_stride_output;
			info->alpha_channel = alpha_channel;
			info->flags = flags;
			info->type = type;
			info->edge_horizontal = edge_horizontal;
			info->edge_vertical = edge_vertical;
			info->colorspace = colorspace;
			info->horizontal_coefficient_width =
				stbir__get_coefficient_width(info->horizontal_filter, info->horizontal_scale);
			info->vertical_coefficient_width =
				stbir__get_coefficient_width(info->vertical_filter, info->vertical_scale);
			info->horizontal_filter_pixel_width =
				stbir__get_filter_pixel_width(info->horizontal_filter, info->horizontal_scale);
			info->vertical_filter_pixel_width =
				stbir__get_filter_pixel_width(info->vertical_filter, info->vertical_scale);
			info->horizontal_filter_pixel_margin =
				stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
			info->vertical_filter_pixel_margin =
				stbir__get_filter_pixel_margin(info->vertical_filter, info->vertical_scale);
			info->ring_buffer_length_bytes = info->output_w * info->channels * sizeof(float);
			info->decode_buffer_pixels = info->input_w + info->horizontal_filter_pixel_margin * 2;
			info->horizontal_contributors = (stbir__contributors*)tempmem;
			info->horizontal_coefficients =
				(float*)((byte*)info->horizontal_contributors + info->horizontal_contributors_size);
			info->vertical_contributors =
				(stbir__contributors*)((byte*)info->horizontal_coefficients + info->horizontal_coefficients_size);
			info->vertical_coefficients =
				(float*)((byte*)info->vertical_contributors + info->vertical_contributors_size);
			info->decode_buffer = (float*)((byte*)info->vertical_coefficients + info->vertical_coefficients_size);
			if (stbir__use_height_upsampling(info) != 0)
			{
				info->horizontal_buffer = null;
				info->ring_buffer = (float*)((byte*)info->decode_buffer + info->decode_buffer_size);
				info->encode_buffer = (float*)((byte*)info->ring_buffer + info->ring_buffer_size);
			}
			else
			{
				info->horizontal_buffer = (float*)((byte*)info->decode_buffer + info->decode_buffer_size);
				info->ring_buffer = (float*)((byte*)info->horizontal_buffer + info->horizontal_buffer_size);
				info->encode_buffer = null;
			}

			info->ring_buffer_begin_index = -1;
			stbir__calculate_filters(info->horizontal_contributors, info->horizontal_coefficients,
				info->horizontal_filter, info->horizontal_scale, info->horizontal_shift, info->input_w, info->output_w);
			stbir__calculate_filters(info->vertical_contributors, info->vertical_coefficients, info->vertical_filter,
				info->vertical_scale, info->vertical_shift, info->input_h, info->output_h);
			if (stbir__use_height_upsampling(info) != 0)
				stbir__buffer_loop_upsample(info);
			else
				stbir__buffer_loop_downsample(info);
			return 1;
		}

		public static int stbir__resize_arbitrary(void* input_data, int input_w, int input_h, int input_stride_in_bytes,
			void* output_data, int output_w, int output_h, int output_stride_in_bytes, float s0, float t0, float s1,
			float t1, float* transform, int channels, int alpha_channel, uint flags, int type, int h_filter,
			int v_filter, int edge_horizontal, int edge_vertical, int colorspace)
		{
			var info = new stbir__info();
			var result = 0;
			ulong memory_required = 0;
			void* extra_memory;
			stbir__setup(&info, input_w, input_h, output_w, output_h, channels);
			stbir__calculate_transform(&info, s0, t0, s1, t1, transform);
			stbir__choose_filter(&info, h_filter, v_filter);
			memory_required = stbir__calculate_memory(&info);
			extra_memory = CRuntime.malloc(memory_required);
			if (extra_memory == null)
				return 0;
			result = stbir__resize_allocated(&info, input_data, input_stride_in_bytes, output_data,
				output_stride_in_bytes, alpha_channel, flags, type, edge_horizontal, edge_vertical, colorspace,
				extra_memory, memory_required);
			CRuntime.free(extra_memory);
			return result;
		}

		public static int stbir_resize_uint8(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, -1, 0, STBIR_TYPE_UINT8,
				STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT, STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP,
				STBIR_COLORSPACE_LINEAR);
		}

		public static int stbir_resize_float(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, -1, 0, STBIR_TYPE_FLOAT,
				STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT, STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP,
				STBIR_COLORSPACE_LINEAR);
		}

		public static int stbir_resize_uint8_srgb(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT, STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP,
				STBIR_COLORSPACE_SRGB);
		}

		public static int stbir_resize_uint8_srgb_edgemode(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT, edge_wrap_mode, edge_wrap_mode,
				STBIR_COLORSPACE_SRGB);
		}

		public static int stbir_resize_uint8_generic(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				STBIR_TYPE_UINT8, filter, filter, edge_wrap_mode, edge_wrap_mode, space);
		}

		public static int stbir_resize_uint16_generic(ushort* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, ushort* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				STBIR_TYPE_UINT16, filter, filter, edge_wrap_mode, edge_wrap_mode, space);
		}

		public static int stbir_resize_float_generic(float* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, float* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				STBIR_TYPE_FLOAT, filter, filter, edge_wrap_mode, edge_wrap_mode, space);
		}

		public static int stbir_resize(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, null, num_channels, alpha_channel, (uint)flags,
				datatype, filter_horizontal, filter_vertical, edge_mode_horizontal, edge_mode_vertical, space);
		}

		public static int stbir_resize_subpixel(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, float x_scale, float y_scale, float x_offset, float y_offset)
		{
			var transform = stackalloc float[4];
			transform[0] = x_scale;
			transform[1] = y_scale;
			transform[2] = x_offset;
			transform[3] = y_offset;
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, 0, 0, 1, 1, transform, num_channels, alpha_channel,
				(uint)flags, datatype, filter_horizontal, filter_vertical, edge_mode_horizontal, edge_mode_vertical,
				space);
		}

		public static int stbir_resize_region(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, float s0, float t0, float s1, float t1)
		{
			return stbir__resize_arbitrary(input_pixels, input_w, input_h, input_stride_in_bytes, output_pixels,
				output_w, output_h, output_stride_in_bytes, s0, t0, s1, t1, null, num_channels, alpha_channel,
				(uint)flags, datatype, filter_horizontal, filter_vertical, edge_mode_horizontal, edge_mode_vertical,
				space);
		}
	}
}