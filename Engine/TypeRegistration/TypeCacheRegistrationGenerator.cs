using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace Staple
{
    [Generator]
    public class TypeCacheRegistrationGenerator : ISourceGenerator
    {
        private const bool verbose = false;

        private readonly string[] blacklistedNamespaces =
        [
            "MessagePack",
            "NAudio",
            "JoltPhysicsSharp",
            "NVorbis",
            "GLFW",
            "SDL2",
            "Bgfx",
            "DrLibs",
            "OpenAL",
            "Newtonsoft",
            "NUnit",
            "NuGet",
            "Hexa",
            "ImGui",
            "Android",
            "Java",
            "Javax",
            "Org",
            "Xamarin",
            "_Microsoft",
            "Dalvik",
        ];

        public void Initialize(GeneratorInitializationContext context)
        {
            /*
            if(!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
            */
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var source = $@"// <auto-generated />
using System;
using System.Runtime.InteropServices;

namespace StapleCodeGeneration
{{
    public static class TypeCacheRegistration
    {{
        public static void RegisterAll()
        {{
            Staple.Internal.TypeCache.Clear();
";

            var types = new HashSet<string>();
            var constructibleTypes = new HashSet<string>();
            var componentTypes = new HashSet<string>();
            var typeSizes = new Dictionary<string, int>();

            void Perform(IAssemblySymbol symbol, bool isSelf)
            {
                void HandleNamedSymbol(INamedTypeSymbol t, string baseTypeName)
                {
                    if (t.IsAbstract || t.IsGenericType || t.Name.EndsWith("Attribute") ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || isSelf == false)) ||
                        t.TypeKind == TypeKind.Enum ||
                        t.TypeKind == TypeKind.Delegate)
                    {
                        if(verbose)
                        {
                            source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";
                        }

                        return;
                    }

                    var typeName = baseTypeName.Length == 0 ? t.Name : $"{baseTypeName}.{t.Name}";

                    Debug.WriteLine($"Adding type {typeName}");

                    if (typeName.Contains("e__FixedBuffer"))
                    {
                        if (verbose)
                        {
                            source += $"            //Processing to {typeName}. Skipped (FixedBuffer)\r\n";
                        }

                        return;
                    }

                    if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                    {
                        if (verbose)
                        {
                            source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";
                        }

                        return;
                    }

                    types.Add(typeName);

                    if(t.IsStatic == false &&
                        (t.Constructors.Any(x => x.Parameters.Length == 0) ||
                        t.TypeKind == TypeKind.Struct))
                    {
                        constructibleTypes.Add(typeName);
                    }

                    if(t.AllInterfaces.Any(x => x.ContainingNamespace?.Name == "Staple" && x.Name == "IComponent"))
                    {
                        componentTypes.Add(typeName);
                    }

                    foreach(var member in t.GetMembers().Where(x => x.Kind == SymbolKind.Field))
                    {
                        HandleSymbol(member);
                    }

                    foreach (var type in t.GetTypeMembers())
                    {
                        HandleNamedSymbol(type, baseTypeName.Length == 0 ? t.Name : $"{baseTypeName}.{t.Name}");
                    }
                }

                void HandleSymbol(ISymbol t)
                {
                    if (t.IsAbstract || t.Name.EndsWith("Attribute") ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || isSelf == false)) ||
                        t.ContainingType.TypeKind == TypeKind.Enum ||
                        t.ContainingType.TypeKind == TypeKind.Delegate)
                    {
                        if (verbose)
                        {
                            source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";
                        }

                        return;
                    }

                    Debug.WriteLine($"Entering type {t.Name}");

                    if (verbose)
                    {
                        source += $"            //Entering type: {t.Name} ({t.GetType().FullName})\r\n";
                    }

                    void HandleTypeSymbol(ITypeSymbol symbol)
                    {
                        var displayFormat = new SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle.Omitted,
                            SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                            SymbolDisplayGenericsOptions.IncludeTypeParameters);

                        var typeName = symbol.ToDisplayString(NullableFlowState.None, displayFormat);

                        if (typeName.EndsWith("*"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (pointer)\r\n";
                            }

                            return;
                        }

                        if(typeName.StartsWith("MessagePack"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (MessagePack)\r\n";
                            }

                            return;
                        }

                        if(typeName.Contains("e__FixedBuffer"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (FixedBuffer)\r\n";
                            }

                            return;
                        }

                        if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                        {
                            if (verbose)
                            {
                                source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";
                            }

                            return;
                        }

                        Debug.WriteLine($"Resolved to {typeName}");

                        if (verbose)
                        {
                            source += $"            //Resolved to {typeName}\r\n";
                        }

                        types.Add(typeName);

                        if (symbol.IsStatic == false &&
                            new List<TypeKind>([TypeKind.Enum, TypeKind.Class, TypeKind.Struct]).Contains(symbol.TypeKind))
                        {
                            constructibleTypes.Add(typeName);
                        }
                    }

                    if (t is IFieldSymbol field)
                    {
                        HandleTypeSymbol(field.Type);
                    }
                    else if(t is IPropertySymbol property)
                    {
                        HandleTypeSymbol(property.Type);
                    }
                }

                void HandleNamespace(INamespaceSymbol n)
                {
                    if(n.Name == "System" || n.Name == "Microsoft")
                    {
                        return;
                    }

                    var namespaceName = n.Name;

                    void Name(INamespaceSymbol s)
                    {
                        if(s == null || s.Name.Length == 0)
                        {
                            return;
                        }

                        namespaceName = $"{s.Name}.{namespaceName}";

                        if(s.ContainingNamespace != null)
                        {
                            Name(s.ContainingNamespace);
                        }
                    }

                    Name(n.ContainingNamespace);

                    foreach (var t in n.GetTypeMembers())
                    {
                        HandleNamedSymbol(t, namespaceName);
                    }

                    foreach (var ns in n.GetNamespaceMembers())
                    {
                        HandleNamespace(ns);
                    }
                }

                foreach (var n in symbol.GlobalNamespace.GetNamespaceMembers())
                {
                    HandleNamespace(n);
                }

                HandleNamespace(symbol.GlobalNamespace);
            }

            foreach (var symbol in context.Compilation.SourceModule.ReferencedAssemblySymbols)
            {
                Perform(symbol, false);
            }

            Perform(context.Compilation.SourceModule.ContainingAssembly, true);

            foreach(var type in types)
            {
                /*
                if(type.StartsWith("System.") && !type.StartsWith("System.Collections"))
                {
                    continue;
                }
                */

                bool skip = false;

                foreach(var item in blacklistedNamespaces)
                {
                    if(type.StartsWith($"{item}."))
                    {
                        skip = true;

                        break;
                    }
                }

                if(skip)
                {
                    continue;
                }

                //source += $"            Console.WriteLine(\"Registering {type}\");\r\n\r\n";

                var constructorSnippet = "";

                var sizeofSnippet = constructibleTypes.Contains(type) ? $@"
                () =>
                {{
                    return Marshal.SizeOf<{type}>();
                }},
" : "null,\n";

                if(constructibleTypes.Contains(type))
                {
                    constructorSnippet = $@"
                (length) =>
                {{
                    return new {type}[length];
                }},
";
                }
                else
                {
                    constructorSnippet = "null, ";
                }

                if (componentTypes.Contains(type) && constructibleTypes.Contains(type))
                {
                    source += $@"
            Staple.Internal.TypeCache.RegisterType(typeof({type}),
                {sizeofSnippet}
                {constructorSnippet}
                new() 
                {{
                    add = (entity) => entity.AddComponent<{type}>(),
                    remove = (entity) => entity.RemoveComponent<{type}>(),
                    get = (entity) => entity.GetComponent<{type}>(),
                }});

";
                }
                else
                {
                    source += $@"
            Staple.Internal.TypeCache.RegisterType(typeof({type}),
                {sizeofSnippet}
                {constructorSnippet}
                null);
";
                }
            }

            source += $@"
        }}
    }}
}}";

            context.AddSource("TypeCacheRegistration.Generated.cs", SourceText.From(source, Encoding.UTF8));
        }
    }
}
