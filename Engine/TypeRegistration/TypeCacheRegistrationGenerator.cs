using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace Staple
{
    [Generator]
    public class TypeCacheRegistrationGenerator : IIncrementalGenerator
    {
        private const bool verbose = false;

        private readonly string[] blacklistedNamespaces =
        [
            "MessagePack.",
            "NAudio.",
            "JoltPhysicsSharp.",
            "NVorbis.",
            "GLFW.",
            "SDL2.",
            "SDL3.",
            "Bgfx.",
            "DrLibs.",
            "OpenAL.",
            "Newtonsoft.",
            "NUnit.",
            "NuGet.",
            "Hexa.",
            "ImGui.",
            "Android.",
            "Java.",
            "Javax.",
            "Org.",
            "Xamarin.",
            "_Microsoft.",
            "Dalvik.",
            "NfdSharp.",
            "System.Reflection.",
            "System.Collections.Generic.I",
            "System.Func",
            "System.Action",
        ];

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var excludedTypes = new List<string>();

            var configFile = context.AdditionalTextsProvider.Where(x => x.Path.EndsWith("TypeExclusions.txt"))
                .Select((file, token) => file.GetText(token)?.ToString())
                .Select((text, _) =>
                {
                    if(string.IsNullOrEmpty(text))
                    {
                        return [];
                    }

                    return text
                        .Split('\n')
                        .Select(x => x.Trim())
                        .ToList();
                })
                .Collect();

            var source = $@"// <auto-generated />
using System;
using System.Runtime.InteropServices;

namespace StapleCodeGeneration
{{
    public static class TypeCacheRegistration
    {{
        public static void RegisterAll()
        {{
";

            var types = new HashSet<string>();
            var constructibleTypes = new HashSet<string>();
            var sizableTypes = new HashSet<string>();
            var componentTypes = new HashSet<string>();
            var typeSizes = new Dictionary<string, int>();

            void Perform(IAssemblySymbol symbol, bool isSelf)
            {
                void HandleNamedSymbol(INamedTypeSymbol t, string baseTypeName)
                {
                    if (t.IsAbstract || t.IsGenericType || t.IsStatic || t.Name.EndsWith("Attribute") ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || !isSelf)) ||
                        t.TypeKind == TypeKind.Delegate)
                    {
                        if (verbose)
                        {
                            source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";
                        }

                        return;
                    }

                    var typeName = baseTypeName.Length == 0 ? t.Name : $"{baseTypeName}.{t.Name}";

                    Debug.WriteLine($"Adding type {typeName}");

                    if (excludedTypes.Contains(typeName))
                    {
                        source += $"            //Found {typeName}. Skipped (excluded)\r\n";

                        return;
                    }

                    if (typeName.Contains("e__FixedBuffer"))
                    {
                        if (verbose)
                        {
                            source += $"            //Processing to {typeName}. Skipped (FixedBuffer)\r\n";
                        }

                        return;
                    }

                    if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                    {
                        if (verbose)
                        {
                            source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";
                        }

                        return;
                    }

                    types.Add(typeName);

                    if (!t.IsStatic &&
                        (t.Constructors.Any(x => x.Parameters.Length == 0) ||
                        t.TypeKind == TypeKind.Struct ||
                        t.TypeKind == TypeKind.Interface))
                    {
                        constructibleTypes.Add(typeName);
                    }

                    if (!t.IsStatic &&
                        (t.Constructors.Any(x => x.Parameters.Length == 0) ||
                        t.TypeKind == TypeKind.Struct))
                    {
                        sizableTypes.Add(typeName);
                    }

                    if (t.AllInterfaces.Any(x => x.ContainingNamespace?.Name == "Staple" && x.Name == "IComponent"))
                    {
                        componentTypes.Add(typeName);
                    }

                    foreach (var member in t.GetMembers().Where(x => x.Kind == SymbolKind.Field))
                    {
                        HandleSymbol(member);
                    }

                    foreach (var type in t.GetTypeMembers())
                    {
                        HandleNamedSymbol(type, baseTypeName.Length == 0 ? t.Name : $"{baseTypeName}.{t.Name}");
                    }
                }

                void HandleSymbol(ISymbol t)
                {
                    if (t.IsAbstract || t.Name.EndsWith("Attribute") || t.IsStatic ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || !isSelf)) ||
                        t.ContainingType.TypeKind == TypeKind.Delegate)
                    {
                        if (verbose)
                        {
                            source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";
                        }

                        return;
                    }

                    Debug.WriteLine($"Entering type {t.Name}");

                    if (verbose)
                    {
                        source += $"            //Entering type: {t.Name} ({t.GetType().FullName})\r\n";
                    }

                    void HandleTypeSymbol(ITypeSymbol symbol)
                    {
                        var displayFormat = new SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle.Omitted,
                            SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                            SymbolDisplayGenericsOptions.IncludeTypeParameters);

                        var typeName = symbol.ToDisplayString(NullableFlowState.None, displayFormat);

                        if (excludedTypes.Contains(typeName))
                        {
                            source += $"            //Found {typeName}. Skipped (excluded)\r\n";

                            return;
                        }

                        if (typeName.EndsWith("*"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (pointer)\r\n";
                            }

                            return;
                        }

                        if (typeName.StartsWith("MessagePack"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (MessagePack)\r\n";
                            }

                            return;
                        }

                        if (typeName.Contains("e__FixedBuffer"))
                        {
                            if (verbose)
                            {
                                source += $"            //Resolved to {typeName}. Skipped (FixedBuffer)\r\n";
                            }

                            return;
                        }

                        if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                        {
                            if (verbose)
                            {
                                source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";
                            }

                            return;
                        }

                        Debug.WriteLine($"Resolved to {typeName}");

                        if (verbose)
                        {
                            source += $"            //Resolved to {typeName}\r\n";
                        }

                        types.Add(typeName);

                        if (!symbol.IsStatic &&
                            new List<TypeKind>([TypeKind.Enum, TypeKind.Class, TypeKind.Struct])
                                .Contains(symbol.TypeKind))
                        {
                            sizableTypes.Add(typeName);
                        }

                        if (!symbol.IsStatic &&
                            new List<TypeKind>([TypeKind.Enum, TypeKind.Class, TypeKind.Struct, TypeKind.Interface])
                                .Contains(symbol.TypeKind))
                        {
                            constructibleTypes.Add(typeName);
                        }
                    }

                    if (t is IFieldSymbol field)
                    {
                        HandleTypeSymbol(field.Type);
                    }
                    else if (t is IPropertySymbol property)
                    {
                        HandleTypeSymbol(property.Type);
                    }
                }

                void HandleNamespace(INamespaceSymbol n)
                {
                    if (n.Name == "System" || n.Name == "Microsoft")
                    {
                        return;
                    }

                    var namespaceName = n.Name;

                    void Name(INamespaceSymbol s)
                    {
                        if (s == null || s.Name.Length == 0)
                        {
                            return;
                        }

                        namespaceName = $"{s.Name}.{namespaceName}";

                        if (s.ContainingNamespace != null)
                        {
                            Name(s.ContainingNamespace);
                        }
                    }

                    Name(n.ContainingNamespace);

                    foreach (var t in n.GetTypeMembers())
                    {
                        HandleNamedSymbol(t, namespaceName);
                    }

                    foreach (var ns in n.GetNamespaceMembers())
                    {
                        HandleNamespace(ns);
                    }
                }

                foreach (var n in symbol.GlobalNamespace.GetNamespaceMembers())
                {
                    HandleNamespace(n);
                }

                HandleNamespace(symbol.GlobalNamespace);
            }

            context.RegisterSourceOutput(context.CompilationProvider.Combine(configFile),
                (sourceContext, compilation) =>
            {
                excludedTypes = compilation.Right.ToString()
                    .Split('\n')
                    .Select(x => x.Trim())
                    .ToList();

                var module = compilation.Left.SourceModule;

                foreach (var symbol in module.ReferencedAssemblySymbols)
                {
                    Perform(symbol, false);
                }

                Perform(module.ContainingAssembly, true);

                foreach (var type in types)
                {
                    /*
                    if(type.StartsWith("System.") && !type.StartsWith("System.Collections"))
                    {
                        continue;
                    }
                    */

                    bool skip = false;

                    foreach (var item in blacklistedNamespaces)
                    {
                        if (type.StartsWith(item))
                        {
                            skip = true;

                            break;
                        }
                    }

                    if (skip)
                    {
                        continue;
                    }

                    //source += $"            Console.WriteLine(\"Registering {type}\");\r\n\r\n";

                    var constructorSnippet = "";

                    var sizeofSnippet = sizableTypes.Contains(type) ? $@"
                () =>
                {{
                    return Marshal.SizeOf<{type}>();
                }},
" : "null,\n";

                    if (constructibleTypes.Contains(type))
                    {
                        constructorSnippet = $@"
                (length) =>
                {{
                    return new {type}[length];
                }},
";
                    }
                    else
                    {
                        constructorSnippet = "null, ";
                    }

                    if (componentTypes.Contains(type) && constructibleTypes.Contains(type))
                    {
                        source += $@"
            Staple.Internal.TypeCache.RegisterType(typeof({type}),
                {sizeofSnippet}
                {constructorSnippet}
                new() 
                {{
                    add = (entity) => entity.AddComponent<{type}>(),
                    remove = (entity) => entity.RemoveComponent<{type}>(),
                    get = (entity) => entity.GetComponent<{type}>(),
                }});

";
                    }
                    else
                    {
                        source += $@"
            Staple.Internal.TypeCache.RegisterType(typeof({type}),
                {sizeofSnippet}
                {constructorSnippet}
                null);
";
                    }
                }

                source += $@"
        }}
    }}
}}";

                sourceContext.AddSource("TypeCacheRegistration.Generated.cs", SourceText.From(source, Encoding.UTF8));
            });
        }
    }
}
